# evaluate the map generated by SLAM against the true map
import ast
import numpy as np
import json
import time

def parse_groundtruth(fname : str) -> dict:
    with open(fname,'r') as f:
        # gt_dict = ast.literal_eval(f.readline())
        gt_dict = json.load(f)
        aruco_dict = {}
        for key in gt_dict:
            if key.startswith("aruco"):
                aruco_num = int(key.strip('aruco')[:-2])
                aruco_dict[aruco_num] = np.reshape([gt_dict[key]["x"], gt_dict[key]["y"]], (2,1))
    return aruco_dict

def parse_user_map(fname : str) -> dict:
    with open(fname, 'r') as f:
        usr_dict = ast.literal_eval(f.read())
        aruco_dict = {}
        for (i, tag) in enumerate(usr_dict["taglist"]):
            aruco_dict[tag] = np.reshape([usr_dict["map"][0][i],usr_dict["map"][1][i]], (2,1))
    return aruco_dict

def match_aruco_points(aruco0 : dict, aruco1 : dict):
    points0 = []
    points1 = []
    keys = []
    for key in aruco0:
        if not key in aruco1:
            continue
        
        points0.append(aruco0[key])
        points1.append(aruco1[key])
        keys.append(key)
    return keys, np.hstack(points0), np.hstack(points1)

def solve_umeyama2d(points1, points2):
    # Solve the optimal transform such that
    # R(theta) * p1_i + t = p2_i

    assert(points1.shape[0] == 2)
    assert(points1.shape[0] == points2.shape[0])
    assert(points1.shape[1] == points2.shape[1])


    # Compute relevant variables
    num_points = points1.shape[1]
    mu1 = 1/num_points * np.reshape(np.sum(points1, axis=1),(2,-1))
    mu2 = 1/num_points * np.reshape(np.sum(points2, axis=1),(2,-1))
    sig1sq = 1/num_points * np.sum((points1 - mu1)**2.0)
    sig2sq = 1/num_points * np.sum((points2 - mu2)**2.0)
    Sig12 = 1/num_points * (points2-mu2) @ (points1-mu1).T

    # Use the SVD for the rotation
    U, d, Vh = np.linalg.svd(Sig12)
    S = np.eye(2)
    if np.linalg.det(Sig12) < 0:
        S[-1,-1] = -1
    
    # Return the result as an angle and a 2x1 vector
    R = U @ S @ Vh
    theta = np.arctan2(R[1,0],R[0,0])
    x = mu2 - R @ mu1

    return theta, x

def apply_transform(theta, x, points):
    # Apply an SE(2) transform to a set of 2D points
    assert(points.shape[0] == 2)
    
    c, s = np.cos(theta), np.sin(theta)
    R = np.array(((c, -s), (s, c)))

    points_transformed =  R @ points + x
    return points_transformed


def compute_rmse(points1, points2):
    # Compute the RMSE between two matched sets of 2D points.
    assert(points1.shape[0] == 2)
    assert(points1.shape[0] == points2.shape[0])
    assert(points1.shape[1] == points2.shape[1])
    num_points = points1.shape[1]
    residual = (points1-points2).ravel()
    MSE = 1.0/num_points * np.sum(residual**2)

    return np.sqrt(MSE)


if __name__ == '__main__':
    import argparse

    parser = argparse.ArgumentParser("Matching the estimated map and the true map")
    parser.add_argument("groundtruth", type=str, help="The ground truth file name.")
    parser.add_argument("--estimate", type=str, help="The estimate file name.", default="lab_output/slam_runX_412.txt")
    args = parser.parse_args()

    gt_aruco = parse_groundtruth(args.groundtruth)
    us_aruco = parse_user_map(args.estimate)
    # print(us_aruco)

    taglist, us_vec, gt_vec = match_aruco_points(us_aruco, gt_aruco)

    rmse = compute_rmse(us_vec, gt_vec)
    print("The RMSE before alignment: {}".format(rmse))

    # Transformation
    theta, x = solve_umeyama2d(us_vec, gt_vec)
    # Manual transformation
    tmp = np.load("offset.npy")
    x_manual = tmp[:2, :]
    x_manual = np.zeros((2,1))
    theta_manual = tmp[-1][0]
    # Apply
    us_vec_aligned = apply_transform(theta, x, us_vec)
    us_vec_manual_al = apply_transform(theta_manual, x_manual, us_vec)
    # Print
    us_aruco_aligned = {}
    for i in range(len(taglist)):
        us_aruco_aligned[taglist[i]] = us_vec_aligned[:,i]
    print("------------")
    print(us_aruco_aligned)
    print("------------")
    print("UMEYAMA transformation params:")
    print("Rotation Angle: {}".format(theta))
    print("Translation Vector: ({}, {})".format(x[0,0], x[1,0]))

    print("Manual transformation params:")
    print("Rotation Angle: {}".format(theta_manual))
    print("Translation Vector: ({}, {})".format(x_manual[0,0], x_manual[1,0]))

    rmse = compute_rmse(us_vec_aligned, gt_vec)
    print("The RMSE with UMEYAMA alignment: {}".format(rmse))
    rmse_manual = compute_rmse(us_vec_manual_al, gt_vec)
    print("The RMSE with manual alignment: {}".format(rmse_manual))

    # print()
    # print("Pred Locations")
    # print(taglist)
    # print("Real Locations")
    # print("np.array(\n"+np.array2string(gt_vec, precision=4, separator=',')+')')
    # print("Aligned Pred Locations")
    # print("np.array(\n"+np.array2string(us_vec_aligned, precision=4, separator=',')+')')
    # print("UN-aligned Pred locations")
    # print("np.array(\n"+np.array2string(us_vec, precision=4, separator=',')+')')
    print("~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n")

    # Plot the three vector on the same graph
    import matplotlib.pyplot as plt
    plt.scatter(gt_vec[0,:], gt_vec[1,:], label="Ground Truth", marker='x')
    plt.scatter(us_vec[0,:], us_vec[1,:], label="Unaligned Estimate", marker='*', linewidths=2)
    plt.scatter(us_vec_manual_al[0,:], us_vec_manual_al[1,:], label="Manual aligned Estimate", marker='o', linewidths=2)
    plt.scatter(us_vec_aligned[0,:], us_vec_aligned[1,:], label="Aligned Estimate", alpha = 0.5)
    plt.legend()
    # limit axis to -1.5 to 1.5
    plt.xlim(-1.5, 1.5)
    plt.ylim(-1.5, 1.5)
    
    # plot x and y axis lines
    plt.axhline(y=0, color='k')
    plt.axvline(x=0, color='k')
    #axes equal
    plt.axis('equal')
    plt.show()
    # plt.savefig(f'slam_eval\slam_eval {time.time()}.png')
    


    # print("debug - coor appear with y first\n")
    # print("user aruco slam:")
    # for tag, coor in us_aruco.items():
    #     x = coor[0]
    #     y = coor[1]
    #     print(tag, y, x)
    # print("aligned:")
    # print(us_vec_aligned)
    print("\n\n")
    
    # Write the aligned pred locations to a file named "aruco_est_pose.txt"
    # # Follow this format
    # '''
    # {"aruco10_0": {"y": -0.6525, "x": -0.5625}, 
    # "aruco1_0": {"y": -0.8099999999999999, "x": 1.1849999999999998}, 
    # "aruco2_0": {"y": 0.3675, "x": 0.32999999999999996}}'''
    # with open("lab_output/aruco_est_pose.txt", 'w') as f:
    #     f.write("{")
    #     for i, tag in enumerate(taglist):
    #         f.write('"aruco{}_0": '.format(tag))
    #         f.write('{{"y": {}, "x": {}}}'.format(us_vec_aligned[1,i], us_vec_aligned[0,i]))
    #         if i != len(taglist)-1:
    #             f.write(',\n')
    #     # f.write("}")
    #     f.write(",\n") # for appending the fruit_est.txt

    # print("lab_output/aruco_est_pose.txt created\n")

